// Copyright 2015 Marc-Antoine Ruel. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

// panicparse: analyzes stack dump of Go processes and simplifies it.
//
// It is mostly useful on servers will large number of identical goroutines,
// making the crash dump harder to read than strictly necesary.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"net/url"
	"os"
	"os/signal"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"

	"github.com/mgutz/ansi"
)

// BUG: Support Windows. https://github.com/shiena/ansicolor seems like a good
// candidate.

var (
	reRoutineHeader = regexp.MustCompile("^goroutine (\\d+) \\[([^\\]]+)\\]\\:$")
	reFile          = regexp.MustCompile("^\t(\\<autogenerated\\>|.+\\.go)\\:(\\d+) \\+0x[0-9a-f]+$")
	reCreated       = regexp.MustCompile("^created by (.+)$")
	reFunc          = regexp.MustCompile("^(.+)\\((.*)\\)$")

	all = flag.Bool("all", false, "print all output before the stack dump")
)

// Call is an item in the stack trace.
type Call struct {
	Path     string // Full path name of the source file
	Line     int    // Line number
	Func     string // Fully qualified function name
	Args     string // Call arguments
	IsStdlib bool   // true if it is a Go standard library function
}

// Base file name of the source file.
func (c *Call) Base() string {
	return filepath.Base(c.Path)
}

// PkgBase is one directory plus the file name of the source file.
func (c *Call) PkgBase() string {
	return filepath.Join(filepath.Base(filepath.Dir(c.Path)), c.Base())
}

// FuncName is the naked function name.
func (c *Call) FuncName() string {
	return filepath.Base(c.Func)
}

// Goroutine represents the state of one goroutine.
type Goroutine struct {
	ID    int
	State string
	Stack []Call
}

// Eq ignores the ID.
func (r *Goroutine) Eq(l *Goroutine) bool {
	if r.State != l.State || len(r.Stack) != len(l.Stack) {
		return false
	}
	for i := range r.Stack {
		if r.Stack[i] != l.Stack[i] {
			return false
		}
	}
	return true
}

func (r *Goroutine) Less(l *Goroutine) bool {
	if r.State < l.State {
		return true
	}
	if r.State > l.State {
		return false
	}
	if len(r.Stack) < len(l.Stack) {
		return true
	}
	if len(r.Stack) > len(l.Stack) {
		return false
	}
	for x := range r.Stack {
		if r.Stack[x].Func < l.Stack[x].Func {
			return true
		}
		if r.Stack[x].Func > l.Stack[x].Func {
			return true
		}
		if r.Stack[x].PkgBase() < l.Stack[x].PkgBase() {
			return true
		}
		if r.Stack[x].PkgBase() > l.Stack[x].PkgBase() {
			return true
		}
		if r.Stack[x].Line < l.Stack[x].Line {
			return true
		}
		if r.Stack[x].Line > l.Stack[x].Line {
			return true
		}
	}
	return false
}

func (r *Goroutine) PrettyStack() string {
	out := []string{}
	for _, line := range r.Stack {
		c := ansi.Red
		if line.IsStdlib {
			c = ansi.Green
		}
		out = append(out, fmt.Sprintf("  %s:%d: %s%s(%s)%s", line.Base(), line.Line, c, line.FuncName(), line.Args, ansi.Reset))
	}
	return strings.Join(out, "\n")
}

// Bucketize returns the number of similar goroutines.
func Bucketize(goroutines []Goroutine) map[*Goroutine]int {
	out := map[*Goroutine]int{}
	// O(nÂ²). Fix eventually.
	for _, r := range goroutines {
		found := false
		for k := range out {
			if r.Eq(k) {
				out[k] += 1
				found = true
				break
			}
		}
		if !found {
			k := &Goroutine{
				ID:    r.ID,
				State: r.State,
				Stack: r.Stack,
			}
			out[k] = 1
		}
	}
	return out
}

// Bucket is a stack trace signature.
type Bucket struct {
	Goroutine
	Count int
}

func (b *Bucket) Less(l *Bucket) bool {
	if b.Count < l.Count {
		return true
	}
	if b.Count > l.Count {
		return false
	}
	return b.Goroutine.Less(&l.Goroutine)
}

// Buckets is a list of Bucket sorted by repeation count.
type Buckets []Bucket

func (b Buckets) Len() int {
	return len(b)
}

func (b Buckets) Less(i, j int) bool {
	return b[i].Less(&b[j])
}

func (b Buckets) Swap(i, j int) {
	b[j], b[i] = b[i], b[j]
}

// SortBuckets creates a list of Bucket from each goroutine stack trace count.
func SortBuckets(buckets map[*Goroutine]int) Buckets {
	out := make(Buckets, 0, len(buckets))
	for r, count := range buckets {
		out = append(out, Bucket{*r, count})
	}
	sort.Sort(out)
	return out
}

// ParseDump processes the output from runtime.Stack().
//
// It supports piping from another command and assumes there is junk before the
// actual stack trace.
func ParseDump(r io.Reader) (string, []Goroutine, error) {
	goroot := runtime.GOROOT()
	goroutines := make([]Goroutine, 0, 16)
	var goroutine *Goroutine
	scanner := bufio.NewScanner(r)
	scanner.Split(bufio.ScanLines)
	header := ""
	for scanner.Scan() {
		line := scanner.Text()
		if len(line) == 0 {
			if goroutine == nil {
				header += line + "\n"
			}
			goroutine = nil
			continue
		}

		if goroutine == nil {
			if match := reRoutineHeader.FindStringSubmatch(line); match != nil {
				if id, err := strconv.Atoi(match[1]); err == nil {
					goroutines = append(goroutines, Goroutine{ID: id, State: match[2], Stack: []Call{}})
					goroutine = &goroutines[len(goroutines)-1]
					continue
				}
			}
			header += line + "\n"
			continue
		}

		if match := reFile.FindStringSubmatch(line); match != nil {
			num, err := strconv.Atoi(match[2])
			if err != nil {
				return header, goroutines, fmt.Errorf("failed to parse int on line: \"%s\"", line)
			}
			i := len(goroutine.Stack) - 1
			p := match[1]
			goroutine.Stack[i].Path = p
			goroutine.Stack[i].Line = num
			goroutine.Stack[i].IsStdlib = strings.HasPrefix(p, goroot)
		} else if match := reCreated.FindStringSubmatch(line); match != nil {
			f, _ := url.QueryUnescape(match[1])
			goroutine.Stack = append(goroutine.Stack, Call{Func: f, Args: match[2]})
		} else if match := reFunc.FindStringSubmatch(line); match != nil {
			f, _ := url.QueryUnescape(match[1])
			goroutine.Stack = append(goroutine.Stack, Call{Func: f, Args: match[2]})
		} else {
			header += line + "\n"
			goroutine = nil
		}
	}
	return header, goroutines, scanner.Err()
}

func mainImpl() error {
	c := make(chan os.Signal)
	go func() {
		for {
			<-c
		}
	}()
	signal.Notify(c, os.Interrupt)

	flag.Parse()
	var in *os.File
	switch name := flag.Arg(0); {
	case name == "":
		in = os.Stdin
	default:
		var err error
		if in, err = os.Open(name); err != nil {
			return err
		}
		defer in.Close()
	}

	header, goroutines, err := ParseDump(in)
	if err != nil {
		return err
	}
	if *all {
		fmt.Printf("%s\n", header)
	}
	for _, r := range SortBuckets(Bucketize(goroutines)) {
		fmt.Printf("%d: %s\n%s\n", r.Count, r.State, r.PrettyStack())
	}
	return err
}

func main() {
	if err := mainImpl(); err != nil {
		fmt.Fprintf(os.Stderr, "Failed: %s\n", err)
		os.Exit(1)
	}
}
